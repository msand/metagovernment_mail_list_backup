<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [MG] Fwd: Re: Fwd: Re: Democratizing Blockchain Governance in Versioning
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:start%40metagovernment.org?Subject=Re%3A%20%5BMG%5D%20Fwd%3A%20Re%3A%20Fwd%3A%20Re%3A%20Democratizing%20Blockchain%20Governance%20in%0A%20Versioning&In-Reply-To=%3C6cd4b1be-a857-23d8-1600-810433ab6bc3%40earthlink.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017571.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MG] Fwd: Re: Fwd: Re: Democratizing Blockchain Governance in Versioning</H1>
    <B>Ned Conner</B> 
    <A HREF="mailto:start%40metagovernment.org?Subject=Re%3A%20%5BMG%5D%20Fwd%3A%20Re%3A%20Fwd%3A%20Re%3A%20Democratizing%20Blockchain%20Governance%20in%0A%20Versioning&In-Reply-To=%3C6cd4b1be-a857-23d8-1600-810433ab6bc3%40earthlink.net%3E"
       TITLE="[MG] Fwd: Re: Fwd: Re: Democratizing Blockchain Governance in Versioning">npconner at earthlink.net
       </A><BR>
    <I>Tue Apr 17 22:07:00 EDT 2018</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="017571.html">[MG] Fwd: Re:  Democratizing Blockchain Governance in Versioning
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html">[ date ]</a>
              <a href="thread.html">[ thread ]</a>
              <a href="subject.html">[ subject ]</a>
              <a href="author.html">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
Mikael, I for one am finding your remarks very useful. You are now on my 
list as someone to approach for advice when my project reaches the point 
of having to deal with these sorts of issues. (No good essay goes 
unpunished ... :-D)


On 4/17/2018 12:00 PM, Mikael Sand wrote:
&gt;<i>
</I>&gt;<i> Managed to send it privately again. I need to pay more attention to 
</I>&gt;<i> where I'm clicking ;)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -------- Forwarded Message --------
</I>&gt;<i> Subject: 	Re: [MG] Democratizing Blockchain Governance in Versioning
</I>&gt;<i> Date: 	Tue, 17 Apr 2018 21:59:06 +0300
</I>&gt;<i> From: 	Mikael Sand &lt;<A HREF="http://metagovernment.org/mailman/listinfo/start_metagovernment.org">msand at abo.fi</A>&gt;
</I>&gt;<i> To: 	Scott Raney &lt;<A HREF="http://metagovernment.org/mailman/listinfo/start_metagovernment.org">metamerman at gmail.com</A>&gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Oh sorry, did intend it for the list. I'll resend it, and, I guess I 
</I>&gt;<i> can just reply to your new comments here as you asked to repost. You 
</I>&gt;<i> can repost your mail in between as well if you wish, but I'll try to 
</I>&gt;<i> keep your replies intact.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On 4/16/2018 11:42 PM, Scott Raney wrote:
</I>&gt;&gt;<i> Did you intend to send this just to me, or to the metagovernment list
</I>&gt;&gt;<i> too?  Let me know, and I'll repost this message to that list if
</I>&gt;&gt;<i> needed...
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On Sun, Apr 15, 2018 at 12:09 PM, Mikael Sand&lt;<A HREF="http://metagovernment.org/mailman/listinfo/start_metagovernment.org">msand at abo.fi</A>&gt;  wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> (big snip: sounds a little &quot;conspiracy theoretical&quot; to me...)
</I>&gt;<i> I understand your sentiment, unfortunately the security faults are 
</I>&gt;<i> available in published research, I can dig up some peer-reviewed 
</I>&gt;<i> papers and videos from IT security conferences if you're interested, 
</I>&gt;<i> but some googling should suffice to find how to do it yourself with 
</I>&gt;<i> relative ease (often with source code, sometimes just the rough sketch 
</I>&gt;<i> of it). The chaos communication congress, black hat and def con 
</I>&gt;<i> conference materials should have you taking out your tinfoil hat quite 
</I>&gt;<i> fast if you're sensitive to conspiratorial speculation. But the 
</I>&gt;<i> technology exists, and just accounts for the consequences of the 
</I>&gt;<i> current physical implementations, hardware and protocol designs, and 
</I>&gt;<i> can mostly be verified simply by thinking from first principles and 
</I>&gt;<i> the specifications. I'm not theorizing about who might be conspiring 
</I>&gt;<i> to use this or not, for whatever reasons, I just either include these 
</I>&gt;<i> published facts in a specific IT security threat model, or not, 
</I>&gt;<i> depending on the use-case, for most IT systems they're completely 
</I>&gt;<i> irrelevant. The importance is not on if it is happening, but rather if 
</I>&gt;<i> it is theoretically possible at all, physically possible to do within 
</I>&gt;<i> a certain budget, and if the relevant potential actors have incentives 
</I>&gt;<i> to spend that budget on it.
</I>&gt;<i>
</I>&gt;<i> If you work with IT security you need to take these publications into 
</I>&gt;<i> account in some of your threat models either way, they can of course 
</I>&gt;<i> have varying levels of paranoia in their assumptions, like if you 
</I>&gt;<i> include state actors and intelligence agencies as potential 
</I>&gt;<i> adversaries in them it completely changes the picture. Even the top 
</I>&gt;<i> level domain resolution of the dns system, certificate authorities and 
</I>&gt;<i> the signalling system 7 (used to set up and route connections, 
</I>&gt;<i> phone-calls and sms etc.) have known faults and lacks trust in this 
</I>&gt;<i> case. DNSSEC and DNSCrypt helps somewhat, but only keys shared and 
</I>&gt;<i> verified either in physical contact or over already secured 
</I>&gt;<i> communications channels and webs of trust has a chance of handling 
</I>&gt;<i> that as far as I know. And, one time padding if you need actual 
</I>&gt;<i> secrecy of course, but that won't scale before we have a cheap source 
</I>&gt;<i> of bell states on a global quantum internet.
</I>&gt;<i>
</I>&gt;<i> Initial trust needs to happen between people who know each other and 
</I>&gt;<i> meet in real life, then a OpenPGP like web of trust can scale the 
</I>&gt;<i> network of public keys used for signing the messages (and encrypting 
</I>&gt;<i> if you need secrecy). Duniter has the most interesting attempt I've 
</I>&gt;<i> seen so far, for building a web-of-trust and handling the identities 
</I>&gt;<i> and accounting of who is still living/interacting with the economy in 
</I>&gt;<i> this manner. The six signatures within the last 100 days and 
</I>&gt;<i> max-distance of six might not be perfect, but have to start 
</I>&gt;<i> experimenting and measuring the results somewhere.
</I>&gt;&gt;&gt;<i> Well, having a centralized service being capable of scaling out and handling
</I>&gt;&gt;&gt;<i> DDOS is one thing. Having it truly p2p and decentralized without any single
</I>&gt;&gt;&gt;<i> points of failure is another, further, having it work when any kind of
</I>&gt;&gt;&gt;<i> network is available is yet another (dat/beakerbrowser might be one of the
</I>&gt;&gt;&gt;<i> easiest ways to share files cross-platform on a lan to this day).
</I>&gt;&gt;<i> The issue of network reliability is really orthogonal to the issue of
</I>&gt;&gt;<i> governance (i.e., we've become dependent on a functioning Internet for
</I>&gt;&gt;<i> far more than just the ability to run the government).
</I>&gt;<i> Well, if you're going to scale the system out and make it distributed 
</I>&gt;<i> to be able to handle large loads, network partitions and ddos attacks, 
</I>&gt;<i> then you'll end up either implementing or using a consensus algorithm 
</I>&gt;<i> of some sort. Are you familiar with the 
</I>&gt;<i> <A HREF="https://en.wikipedia.org/wiki/CAP_theorem">https://en.wikipedia.org/wiki/CAP_theorem</A> ? In short, you can only 
</I>&gt;<i> have two out of these three: consistency, availability and partition 
</I>&gt;<i> tolerance. You mentioned mongodb before, which now supports running a 
</I>&gt;<i> primary (+ secondary replicas) and providing either BASE (Basically 
</I>&gt;<i> Available, Soft state, Eventual consistency) semantics or, starting 
</I>&gt;<i> this summer in v4.0, multi table ACID (Atomicity, Consistency, 
</I>&gt;<i> Isolation, Durability) semantics. What conflict resolution strategy 
</I>&gt;<i> are you suggesting for network partitions? Lets assume AWS or a large 
</I>&gt;<i> part of it goes down for some amount of time, is the service 
</I>&gt;<i> unavailable until the connections recover? And the service would 
</I>&gt;<i> depend on a functioning connection to wider Internet? And thus 
</I>&gt;<i> wouldn't work for organizing people if e.g. the government, a coup, or 
</I>&gt;<i> a foreign military shuts down the telecommunications infrastructure?
</I>&gt;&gt;&gt;<i> Not trusting anyone seems like a fools game, but at least I don't trust
</I>&gt;&gt;&gt;<i> everyone, almost always someone can perceive incentives to exploit for
</I>&gt;&gt;&gt;<i> economic reasons or otherwise.
</I>&gt;&gt;<i> Agreed: And if there's going to be one person you *have* to trust
</I>&gt;&gt;<i> (outside your close friends and family, of course), it's got to be the
</I>&gt;&gt;<i> manager of your local government. Without that, I submit that there
</I>&gt;&gt;<i> *is* no functioning local government.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> (snip, more conspiracy theory stuff)
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Are you suggesting people do it
</I>&gt;&gt;&gt;<i> manually by hand when they for whatever reason feel the urge to check if
</I>&gt;&gt;&gt;<i> their data has been manipulated? And using what process? Opening the website
</I>&gt;&gt;&gt;<i> and checking their profile? How does this say anything about how that data
</I>&gt;&gt;&gt;<i> has been counted or how it relates to other peoples data?
</I>&gt;&gt;<i> For example, in proxyfor.me you can download the complete data file
</I>&gt;&gt;<i> for the vote on any proposal. You can check your vote along with
</I>&gt;&gt;<i> everyone else's as well as ensuring that everything adds up correctly.
</I>&gt;&gt;<i> And anyone who can use a spreadsheet (or even a text editor) can do
</I>&gt;&gt;<i> this. Nothing fancy required, no trust required other than that the
</I>&gt;&gt;<i> Local Manager has verified that the screen names correspond to real
</I>&gt;&gt;<i> people. And again, if you don't trust at least that executive, there
</I>&gt;&gt;<i> *is* no functioning government so this is simply not a problem. And
</I>&gt;&gt;<i> there is even a rough check you can do to detect obvious tampering:
</I>&gt;&gt;<i> Voting rolls are public so we already *know* how many votes there
</I>&gt;&gt;<i> should be...
</I>&gt;<i> So, lets assume you've downloaded the archive once, and do it again to 
</I>&gt;<i> check if any of the old data has changed, and you notice a chunk of it 
</I>&gt;<i> missing or modified? What now? How do we find the culprit? Was it the 
</I>&gt;<i> manager? Some IT admin? A bug? An attack?
</I>&gt;<i> How much traffic can it handle for this?
</I>&gt;<i>
</I>&gt;<i> Lets say, a majority of users (or relatively large number) would 
</I>&gt;<i> decide to download the entire archive once or more per day, is this 
</I>&gt;<i> cost effective? and simple? Perhaps from some perspective, but I don't 
</I>&gt;<i> see how the auditing would be done reliably without making the normal 
</I>&gt;<i> verifying users essentially like a ddos attack once the systems gets 
</I>&gt;<i> large amounts of users. And besides, downloading and checking the data 
</I>&gt;<i> would only detect the issue, not say what caused it, nor resolve it 
</I>&gt;<i> automatically using an algorithm made for distributed systems.
</I>&gt;<i>
</I>&gt;<i> Lets say each user needs to generate a private and public key, and 
</I>&gt;<i> sign their votes/actions/data whenever they add/change something in 
</I>&gt;<i> the service and include a reference to what was the latest version of 
</I>&gt;<i> the state, persist this in an event store, and calculate a checksum 
</I>&gt;<i> from the checksum in the previous last event and the contents of the 
</I>&gt;<i> entire new event (like git). Then we know it was someone in possession 
</I>&gt;<i> of the private key corresponding to the public key of the user who 
</I>&gt;<i> created/caused the change. At this stage you would already have what 
</I>&gt;<i> amounts to a directed acyclic graph. Can very well be stored in 
</I>&gt;<i> mongodb, or essentially any other persistence layer. Then if you just 
</I>&gt;<i> add a consensus algorithm (based e.g. on vector clocks, matrix clocks, 
</I>&gt;<i> interval tree clocks, or general causal trees), you can make it into a 
</I>&gt;<i> distributed system which can handle availability, and using something 
</I>&gt;<i> like latest vote/write wins you can handle conflicts on a per 
</I>&gt;<i> user/private key event log basis to get eventual consistency (and 
</I>&gt;<i> using CRDT and/or OT for real-time collaborative data), thus working 
</I>&gt;<i> in p2p fashion in any network conditions (even highly unreliable and 
</I>&gt;<i> intermittent ones).
</I>&gt;<i>
</I>&gt;<i> Hmm, you intend a local manager to verify the identity of all the 
</I>&gt;<i> people using the system? This seems like quite another bottleneck. 
</I>&gt;<i> What would be the process for verifying the identity? Is the local 
</I>&gt;<i> manager the only one who knows what screen name corresponds to what 
</I>&gt;<i> living person? Or what's the auditing process here? What happens when 
</I>&gt;<i> we notice our dead neighbor adding new votes to the data a few months 
</I>&gt;<i> after them passing away?
</I>&gt;&gt;&gt;<i> At least, each electronic voting system that has been built by/for the
</I>&gt;&gt;&gt;<i> finnish government has been bug ridden and full of insane security problems,
</I>&gt;&gt;&gt;<i> while costing hundreds of millions of euros. I'm not sure what technological
</I>&gt;&gt;&gt;<i> simplifications you're suggesting to achieve reliable and secure software
</I>&gt;&gt;&gt;<i> engineering by/for governments.
</I>&gt;&gt;<i> Well getting rid of the ridiculous &quot;secret ballot&quot; requirement is a
</I>&gt;&gt;<i> big one. It's not necessary and trying to impose it just makes the
</I>&gt;&gt;<i> system non-verifiable. Which perhaps not coincidentally is exactly the
</I>&gt;&gt;<i> same problem any blockchain-based system has: If the average person
</I>&gt;&gt;<i> can't go in and validate the vote count, IMHO the system can never be
</I>&gt;&gt;<i> trusted.
</I>&gt;<i> Secret ballots in paper-less electronic voting are inherently 
</I>&gt;<i> incompatible with verify-ability of either the tally or one person one 
</I>&gt;<i> vote. It makes sense in paper-trail voting, which is required for any 
</I>&gt;<i> vote-buying/coercion sensitive topics and decisions. But as far as I 
</I>&gt;<i> understand now, any kind of public internet voting is only suitable 
</I>&gt;<i> for completely open data. I didn't actually mention secret ballots so 
</I>&gt;<i> far, and I'm not sure why you're bringing it up.
</I>&gt;<i> A private group (already knowing each others public keys) can create 
</I>&gt;<i> issue specific keys shared within the group, and use symmetric 
</I>&gt;<i> cryptography to vote in secret from the public on a public ledger, 
</I>&gt;<i> while maintaining immutability and the potential to audit the decision 
</I>&gt;<i> history later on. But, this is more relevant to e.g. a security 
</I>&gt;<i> conscious boards of directors or some specific interests groups, and 
</I>&gt;<i> will probably be kept in private &quot;block-chains&quot; or using linked 
</I>&gt;<i> timestamping anyway, which is nothing new. Calculating signatures and 
</I>&gt;<i> checksums for data integrity checking has been implemented many times 
</I>&gt;<i> over in e.g. all kinds of military and banking databases, bank-to-bank 
</I>&gt;<i> communications and others considering similar threat vectors etc. long 
</I>&gt;<i> before bitcoin came. Inter-bank comms tend to use some of the best key 
</I>&gt;<i> distribution mechanisms money can buy, then again, many consumer 
</I>&gt;<i> facing internet banking apps / checkout flows have mostly crap 
</I>&gt;<i> security and very basic flaws like no escape character handling 
</I>&gt;<i> together with user modifiable content and hashes, these fall under the 
</I>&gt;<i> &quot;don't give a shit&quot; policy of banks, insurance covers it, and mostly a 
</I>&gt;<i> consumer client risk factor. And, block-chain is mostly just a 
</I>&gt;<i> slightly catchier word that happened to reach the mainstream because 
</I>&gt;<i> of the popularity and hype around bitcoin and other crypto-currencies.
</I>&gt;&gt;&gt;<i> Unless it's based on some
</I>&gt;&gt;&gt;<i> correct-by-construction software design or otherwise proof-based on some
</I>&gt;&gt;&gt;<i> sound type theory, I'm not sure it'll be sufficient, and that is certainly
</I>&gt;&gt;&gt;<i> not a simplification, it easily makes development time 10x or more (I have a
</I>&gt;&gt;&gt;<i> fair share of experience from trying myself, while I was studying for my
</I>&gt;&gt;&gt;<i> computer science masters degree).
</I>&gt;&gt;<i> All software has bugs. The goal is not to produce perfect code, just
</I>&gt;&gt;<i> good enough code such that it does the job *and* having a proper
</I>&gt;&gt;<i> design such that you can at least *detect* when a bug/hack/loss has
</I>&gt;&gt;<i> occurred. Finland's system, along with all blockchain-based systems,
</I>&gt;&gt;<i> fail to deliver the latter, whereas proxyfor.me delivers it easily.
</I>&gt;<i> I'm still confused as to what the auditing process would be in 
</I>&gt;<i> proxyfor.me? What is the conflict resolution method once someone 
</I>&gt;<i> claims they have an older backup including data which is missing 
</I>&gt;<i> and/or some which is fabricated in the current db? What if there are 
</I>&gt;<i> more than one actor claiming this? With mutually conflicting claims?
</I>&gt;<i> How much experience in software development and running distributed 
</I>&gt;<i> system in production do you have? I'm very interested in seeing your 
</I>&gt;<i> design and how it easily verifies the good enough correctness, and its 
</I>&gt;<i> ability to detect bugs, hacks and losses. I'm quite skeptical you've 
</I>&gt;<i> done any of this yet though, without actually recreating what the 
</I>&gt;<i> field of computer scientists and cryptographers have made for these 
</I>&gt;<i> specific purposes. Perhaps there might be some technical jargon I've 
</I>&gt;<i> used which deserves clarification, please ask if I've used some terms 
</I>&gt;<i> too ambiguously or in an unclear way, I'm doing my best to express 
</I>&gt;<i> this as comprehensibly as I can, while I completely understand if it 
</I>&gt;<i> seems very confusing.
</I>&gt;&gt;&gt;<i> I sure trust it to mostly
</I>&gt;&gt;&gt;<i> behave according to the current laws governing money and accounting, as in
</I>&gt;&gt;&gt;<i> the sources and sinks of debt, interest rates and fractional reserve
</I>&gt;&gt;&gt;<i> currency; and the mathematical consequences of those.
</I>&gt;&gt;<i> And that's all I'm assuming you should have to do. Or do with the
</I>&gt;&gt;<i> voting system (i.e., you should have the source code and all the raw
</I>&gt;&gt;<i> input and output data and so can verify its operation).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm certainly not expecting anyone to trust the *political* components
</I>&gt;&gt;<i> of monetary policy, which I agree with you is as screwed up as the
</I>&gt;&gt;<i> rest of government (misrepresentative democracy).
</I>&gt;<i> Hmm, well the source code and a sample of the dataset is not really 
</I>&gt;<i> enough to ensure the correct functioning of a distributed system. 
</I>&gt;<i> Among other things, it doesn't tell if its refusing to respond to some 
</I>&gt;<i> users, or if it only shows what the person attempting to verify the 
</I>&gt;<i> data wants to see about their own data, they would still have to check 
</I>&gt;<i> with others to see if what they see as others data is actually the 
</I>&gt;<i> same as what the others see, and establish some common knowledge, 
</I>&gt;<i> about what they know, what others know, who knows that who knows what 
</I>&gt;<i> transitively, and so on. I'd much rather have the algorithm establish 
</I>&gt;<i> this rather than do it manually. If the specification is a protocol, 
</I>&gt;<i> you don't have to trust the specific implementations, as long as the 
</I>&gt;<i> protocol constrains the possible interactions correctly, you can use 
</I>&gt;<i> any specification compliant client to interact with the network and 
</I>&gt;<i> verify what parts of the data has already reached consensus in what 
</I>&gt;<i> parts of the network.
</I>&gt;&gt;&gt;<i> Do you have any technical objections to this? Or does this boil down to you
</I>&gt;&gt;&gt;<i> wanting the executive branch to be trusted to run a software in a
</I>&gt;&gt;&gt;<i> centralized fashion? For what reasons/benefits? To be &quot;vastly simplified,
</I>&gt;&gt;&gt;<i> improving service levels, reliability, and the ability to detect and deal
</I>&gt;&gt;&gt;<i> with attacks on the system&quot;?
</I>&gt;&gt;<i> Exactly.
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> What becomes simpler for who? What service level/reliability increases?
</I>&gt;&gt;<i> Simpler to understand, simpler implement, simpler to maintain, even in
</I>&gt;&gt;<i> the face of attach (AWS, for example, has *vastly* more capability in
</I>&gt;&gt;<i> dealing with this kind of thing than *any* government has, or could
</I>&gt;&gt;<i> ever hope to have).
</I>&gt;<i> Too simple in fact, at least to be capable of working as a verifiable 
</I>&gt;<i> distributed system; unless you intend to have a single primary, in 
</I>&gt;<i> which case you don't have an actual distributed system with 
</I>&gt;<i> availability, just some extra scaling out for more and faster reads 
</I>&gt;<i> when network conditions are good; or unless you use something like 
</I>&gt;<i> Lamport timestamps/Vector clocks/Matrix clocks/Version 
</I>&gt;<i> vectors/Interval Tree Clocks etc to record the partial ordering of 
</I>&gt;<i> events and capturing the chronological and causal relationship in a 
</I>&gt;<i> distributed manner; and, verification of authenticity, unless you add 
</I>&gt;<i> signatures; and, verification of integrity, unless you add something 
</I>&gt;<i> like merkle trees. What parts of the process confuses you? Or what 
</I>&gt;<i> part is not simple enough? Or what parts of these do you think you're 
</I>&gt;<i> achieving without doing the necessary work? Essentially a relatively 
</I>&gt;<i> simple interface can describe the entire api surface needed in a 
</I>&gt;<i> thin-client, the signature and checksum algorithm choices have 
</I>&gt;<i> acceptable reasoning behind them, otherwise it's a p2p distributed 
</I>&gt;<i> database like almost any other, except that it actually works in an 
</I>&gt;<i> existing browser with self-hosting and authoring capability, like Tim 
</I>&gt;<i> Berners-Lee intended the web to be.
</I>&gt;&gt;&gt;<i> How do external users detect a virus or
</I>&gt;&gt;&gt;<i> backdoor in the actual running system? How does anyone verify what source
</I>&gt;&gt;&gt;<i> code is used?
</I>&gt;&gt;<i> You can't, but that's true of blockchain or any other distributed
</I>&gt;&gt;<i> system. Who do you trust more, one executive that *we* voted into
</I>&gt;&gt;<i> office and can check up on or dozens or even hundreds of unknown
</I>&gt;&gt;<i> servers run by who knows who?
</I>&gt;<i> Well, with a DAG, signature and checksum checking, you can use a 
</I>&gt;<i> consensus algorithm to agree on what data should exist and it doesn't 
</I>&gt;<i> matter as long as less than the majority of the network is infected, 
</I>&gt;<i> and a web-of-trust based system can even handle that to a large 
</I>&gt;<i> degree. I certainly trust cryptography and the very small likelihood 
</I>&gt;<i> that someone would posses/deduce/brute-force all the private keys, 
</I>&gt;<i> much more, than any centralized IT-system without either the required 
</I>&gt;<i> data nor algorithms used for sufficient integrity checking and 
</I>&gt;<i> conflict resolution.
</I>&gt;&gt;<i>   
</I>&gt;&gt;&gt;<i> That the compiler and virtual machines are working correctly?
</I>&gt;&gt;&gt;<i> OS? Spectre variant 2 patches applied? What else is running on the same
</I>&gt;&gt;&gt;<i> hardware and network or has physical access to it? Other side-channel
</I>&gt;&gt;&gt;<i> attacks? How would the centralized admins themselves even do these things?
</I>&gt;&gt;<i> Again, it's got to be open voting so all this secrecy stuff just goes
</I>&gt;&gt;<i> away (who cares if another process on the same CPU can read the voting
</I>&gt;&gt;<i> systems' memory? It's all open and public anyway!)
</I>&gt;<i> Well, it's not about someone being able to read it, everybody being 
</I>&gt;<i> able to read it is actually a requirement rather than something to 
</I>&gt;<i> avoid, a DAG would also have all the data openly readable (unless you 
</I>&gt;<i> write some encrypted data instead of actual text in a comment field or 
</I>&gt;<i> something, or if the protocol allows storing arbitrary data then 
</I>&gt;<i> anything can be stored of course), and anyone wanting to keep their 
</I>&gt;<i> local copy of the database up-to-date is able to, and can vote while 
</I>&gt;<i> off-line/grid and distribute the results once they have a connection 
</I>&gt;<i> again, can even have actual sneakernet as courier of votes/data 
</I>&gt;<i> to/from remote places.
</I>&gt;<i> But rather, it's about the potential for backdoors and user specific 
</I>&gt;<i> massaging of what it responds with, and what is actually used in other 
</I>&gt;<i> calculations/responses. Simply put, the users need to be able to reach 
</I>&gt;<i> consensus about the data in the service, otherwise data can 
</I>&gt;<i> disappear/change without a trace of who/what caused it or any way to 
</I>&gt;<i> resolve the conflict, thus deserving criticism and eroding trust in 
</I>&gt;<i> the system before it even gets started.
</I>&gt;&gt;&gt;<i> It seems to me it opens up several classes of vulnerabilities. I'm not sure
</I>&gt;&gt;&gt;<i> what your threat model and security analysis method is here. But I don't see
</I>&gt;&gt;&gt;<i> anything of substance to back up these claimed benefits.
</I>&gt;&gt;<i> Only if you think like a secrecy-obsessed paranoid. If it's all open
</I>&gt;&gt;<i> nearly all of your reservations simply disappear, and the rest can
</I>&gt;&gt;<i> easily be dealt with by using the best commercially-available services
</I>&gt;&gt;<i> rather than trusting JimBob's basement server or those run by the
</I>&gt;&gt;<i> Russians like the blockchain proponents would propose.
</I>&gt;&gt;<i>    Regards,
</I>&gt;&gt;<i>      Scott
</I>&gt;<i> Well, you might have confused me for someone else, I haven't advocated 
</I>&gt;<i> for secrecy in any public internet voting system or any other kind of 
</I>&gt;<i> e-democracy platform, (perhaps many years ago for privacy sensitive 
</I>&gt;<i> topics, but not since actually looking into building them and reading 
</I>&gt;<i> some of the security analysis around them). The p2p web is essentially 
</I>&gt;<i> the opposite to secrecy. And my concerns are mostly about data 
</I>&gt;<i> integrity and authenticity, to make it good enough such that the 
</I>&gt;<i> security minded people would be happier with proxyfor.me and to make 
</I>&gt;<i> it feasible at all to audit what is going on. I'm not sure how you 
</I>&gt;<i> could have confused any of my reservations being related to secrecy. 
</I>&gt;<i> The only relation to or concern about secrecy is perhaps of someone in 
</I>&gt;<i> the executive branch or an external malicious actor attempting to 
</I>&gt;<i> delete/change/add data in secret.
</I>&gt;<i>
</I>&gt;<i> I'm not sure what you consider &quot;the best commercially-available&quot;, but 
</I>&gt;<i> the <A HREF="https://en.wikipedia.org/wiki/Merkle_tree">https://en.wikipedia.org/wiki/Merkle_tree</A> seems almost universally 
</I>&gt;<i> common. Not sure what brand of it you would consider simple enough. 
</I>&gt;<i> But if the best commercial options suffice, it seems it's ok to use it 
</I>&gt;<i> as long as we don't call it a blockchain, or what counts as simple in 
</I>&gt;<i> distributed systems really? ;) I think you might have confused what 
</I>&gt;<i> I'm suggesting with nakamoto consensus, which I don't think is a good 
</I>&gt;<i> fit for this. Dat, ipfs and (secure scuttlebutt) ssb are perhaps the 
</I>&gt;<i> most evolved forms of merkle trees for the p2p web, even firefox 
</I>&gt;<i> allows supporting <A HREF="dat://">dat://</A> <A HREF="ipfs://">ipfs://</A> and <A HREF="ssb://">ssb://</A> urls now: 
</I>&gt;<i> <A HREF="https://blog.mozilla.org/addons/2018/01/26/extensions-firefox-59/">https://blog.mozilla.org/addons/2018/01/26/extensions-firefox-59/</A> and 
</I>&gt;<i> DNS integration will keep getting better.
</I>&gt;<i>
</I>&gt;<i> Consensus and distributed systems sure ain't very simple to reason 
</I>&gt;<i> about that's for sure. But putting an arbitrary limit somewhere such 
</I>&gt;<i> that it's not even possible to at least eventually resolve conflicts, 
</I>&gt;<i> or that the system is unavailable in network partitions doesn't seem 
</I>&gt;<i> very great. These things need to be dealt with on the protocol level, 
</I>&gt;<i> instead of being hopeful that some lazy it-admins are top notch and 
</I>&gt;<i> keeping everything in shape in a centralized system (especially in 
</I>&gt;<i> government IT, where the contracts tend to go to the same old friends 
</I>&gt;<i> each time, at least in finland), when in reality they tend to be 
</I>&gt;<i> ignorant of many security issues and they don't even admit/know about 
</I>&gt;<i> it/think it's an issue.
</I>&gt;<i>
</I>&gt;<i> If you think that the dat project and the beaker browsers have bad 
</I>&gt;<i> choices in their technological decisions compared to some commercial 
</I>&gt;<i> alternative, I'm very interested in finding out about it and improving 
</I>&gt;<i> the p2p web using it. But I think you might find that the commercially 
</I>&gt;<i> available service implement these same categories of general 
</I>&gt;<i> algorithms, and in many cases the same specific choices, to solve the 
</I>&gt;<i> issues I'm trying to highlight here.
</I>&gt;<i>
</I>&gt;<i> Sorry for the essay length ramblings, hope at least someone finds some 
</I>&gt;<i> of it useful.
</I>&gt;<i>
</I>&gt;<i> Regards,
</I>&gt;<i> Mikael
</I>&gt;<i>
</I>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://metagovernment.org/pipermail/start_metagovernment.org/attachments/20180417/136150cb/attachment-0001.html">http://metagovernment.org/pipermail/start_metagovernment.org/attachments/20180417/136150cb/attachment-0001.html</A>&gt;
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="017571.html">[MG] Fwd: Re:  Democratizing Blockchain Governance in Versioning
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html">[ date ]</a>
              <a href="thread.html">[ thread ]</a>
              <a href="subject.html">[ subject ]</a>
              <a href="author.html">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://metagovernment.org/mailman/listinfo/start_metagovernment.org">More information about the Start
mailing list</a><br>
</body></html>
