<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Start] A half baked vision
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:start%40metagovernment.org?Subject=Re%3A%20%5BStart%5D%20A%20half%20baked%20vision&In-Reply-To=%3C2f14452a0805022025q4f61c72i14d6f91886df8d98%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008954.html">
   <LINK REL="Next"  HREF="008956.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Start] A half baked vision</H1>
    <B>Jacki Buros</B> 
    <A HREF="mailto:start%40metagovernment.org?Subject=Re%3A%20%5BStart%5D%20A%20half%20baked%20vision&In-Reply-To=%3C2f14452a0805022025q4f61c72i14d6f91886df8d98%40mail.gmail.com%3E"
       TITLE="[Start] A half baked vision">jburos at gmail.com
       </A><BR>
    <I>Fri May  2 23:25:43 EDT 2008</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="008954.html">[Start] A half baked vision
</A></li>
        <LI>Next message (by thread): <A HREF="008956.html">[Start] A half baked vision
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html">[ date ]</a>
              <a href="thread.html">[ thread ]</a>
              <a href="subject.html">[ subject ]</a>
              <a href="author.html">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I really like this design .. it is true that the more simple the
design the more easily it can be extended, amended, and/or
supplemented with other tools. Like in *nux, do one thing and do it
well - then pipe output to another program (or several) to accomplish
the specific goal.

I too have reservations about scoring systems -- just because a
person's ideas have been good and widely supported does not mean that
their next idea will be equally as good or equally as supported by the
community. 'Scoring' is basically a fancy version of a representative
government, because each positive rating is like a vote giving that
person representative power.

I'm thinking about the voting behavior -- what if a user could
highlight a section of text and 'vote' yes -- ie, express approval of
the line. highlight a line and 'vote' no or express disapproval. A
user could highlight everything and exclude sections, then vote. this
might help along the process of synthesis, and avoid the problem where
a small edit might lead to the need for a complete re-vote. You could
hover over a section to see how well supported or how contested it is,
rather than see who wrote it. Would this be terribly difficult to
implement?

I do have concerns about having a lack of definition between
communities, at least at the outset. If these texts are to have the
power of law that could affect everyone's lives, then there needs to
be a process by which the government is made legitimate and given the
right to rule -- either by the people directly or by their government.
At some point, if the system were universally adopted, defined
communities may not be necessary but until then, if there is no
defined community then there is no entity called 'the people' who can
grant the metagovernment the right to govern their community. Again,
this problem arises since any transition to an open or meta-government
model will occur on a community-by-community basis and so there will
necessarily be defined communities for some time. I do think, in
service of a more open-government vision, that keeping the design
simple could allow these boundaries between communities to blur with
little difficulty, so that a community can implement the same law as
another community, or several communities could decide to effect a law
in concert.

On Fri, May 2, 2008 at 10:35 PM, Aur Saraf &lt;<A HREF="http://metagovernment.org/mailman/listinfo/start_metagovernment.org">sonoflilit at gmail.com</A>&gt; wrote:
&gt;<i>  * I only care about the software we build. Any philosophy-of-politics
</I>&gt;<i>  discussion right now is meaningless as the masses will decide that the
</I>&gt;<i>  moment we make the tools available, and what they do WILL surprise all
</I>&gt;<i>  of us, if we judge based on the experience of any social application
</I>&gt;<i>  of the web to date
</I>&gt;<i>
</I>&gt;<i>   * I don't really like the division you guys are thinking up to
</I>&gt;<i>  geographic and topical boards. I think one huge lawbook can hold all
</I>&gt;<i>  the legislation for the planet, with tagging making it easier for
</I>&gt;<i>  someone to keep track of just legislation relevant to his town or
</I>&gt;<i>  hobby.
</I>&gt;<i>
</I>&gt;<i>   * I'm still thinking about scoring systems. I'm not sure there's
</I>&gt;<i>  reason for users to have a personal score - it doesn't make much
</I>&gt;<i>  sense, in fact, to have someone's vote count more just because other
</I>&gt;<i>  people liked his suggestions. Maybe the only &quot;score&quot; should be that
</I>&gt;<i>  given to branches of a proposed law, and that used to decide when and
</I>&gt;<i>  which branch and revision get merged to the &quot;release&quot; branch. Maybe
</I>&gt;<i>  also rating comments, but using those ratings just for deciding which
</I>&gt;<i>  comments to display in the client, not for any math that matters to
</I>&gt;<i>  the mechanics of lawmaking. An alternative would be that every time I
</I>&gt;<i>  vote up someone's comment in a law tagged &quot;UK&quot;, &quot;Manchester&quot; and
</I>&gt;<i>  &quot;restaurant&quot; his rankings in these three tags would be affected
</I>&gt;<i>  accordingly, as well as his &quot;generic&quot; ranking, and if he does not yet
</I>&gt;<i>  have a ranking relating to a certain legislation, a fraction of his
</I>&gt;<i>  generic rating would be used by default until he gets one.
</I>&gt;<i>
</I>&gt;<i>   * When thinking about the software, I strive in this order for:
</I>&gt;<i>    * Simplicity of the interface
</I>&gt;<i>    * Flexibility of the interface
</I>&gt;<i>    * Flexibility of the data model
</I>&gt;<i>
</I>&gt;<i>   * I base my design very closely on DRCSs, and use their terminology -
</I>&gt;<i>  revision, branch, commit log... you should try working with one before
</I>&gt;<i>  you read this or you'll need much googling
</I>&gt;<i>
</I>&gt;<i>  The data model would be a directory structure of plaintext files under
</I>&gt;<i>  revision control by a tool like git that allows very cheap branching
</I>&gt;<i>  and advanced merging.
</I>&gt;<i>
</I>&gt;<i>  In the legislations directory you'd have one text file per proposed
</I>&gt;<i>  law (of course, in the &quot;release&quot; branch there would only be those of
</I>&gt;<i>  accepted versions of laws).
</I>&gt;<i>  This text file would contain a lightly-marked-up law. There would be
</I>&gt;<i>  markup for a comment box.
</I>&gt;<i>  At first I thought about markup for user-id and crypto-sig for every
</I>&gt;<i>  sequence of text, but then I realised:
</I>&gt;<i>  1) It would work for comments, since they are not meant to be edited,
</I>&gt;<i>  but for legislation - say I write a sentence, sign it, then you fix a
</I>&gt;<i>  typo, my sig is now unverifiable in the latest revision
</I>&gt;<i>  2) The data is already there in the revision history, so instead of
</I>&gt;<i>  duplicating data, lets have the client traverse the whole history when
</I>&gt;<i>  it displays a file, and remember what was written by whom (and verify
</I>&gt;<i>  the crypto signatures which would be given in the commit log)
</I>&gt;<i>  On second thought,
</I>&gt;<i>
</I>&gt;<i>  There would also be markup for voting, that is comprised of a line
</I>&gt;<i>  containing SSN of voter, rank given by voter and a crypto signature of
</I>&gt;<i>  the string legislationname-branchname-revisionnumber-rankgiven. That
</I>&gt;<i>  means, of course, that a revision's initial score is that of the
</I>&gt;<i>  revision before it - which is in my opinion a correct behavior. We
</I>&gt;<i>  COULD have the engine reduce a tiny bit of score for each new
</I>&gt;<i>  revision, to make it harder to jump-on-the-bandwagon with a tiny
</I>&gt;<i>  change and have YOUR version selected over the one everyone voted for
</I>&gt;<i>  by merit of a handful votes.
</I>&gt;<i>
</I>&gt;<i>  Special attention should be given to how legislations are tagged,
</I>&gt;<i>  since otherwise it would be easy to game the system - you branch an
</I>&gt;<i>  obscure legislation, tag it with a thousand tags, vote for it and have
</I>&gt;<i>  your friends do so too, and suddenly your score in so many tags is
</I>&gt;<i>  up...
</I>&gt;<i>
</I>&gt;<i>  In the users directory you'd have one file per social security number
</I>&gt;<i>  of a user, with a plaintext templated file that has the user's
</I>&gt;<i>  rating(s), bio and userpage (like in wikipedia), perhaps also public
</I>&gt;<i>  key (should this be stored elsewhere? I haven't thought through the
</I>&gt;<i>  security aspects of this thoroughly).
</I>&gt;<i>
</I>&gt;<i>  The interface would be a program that can do the pushing-pulling of
</I>&gt;<i>  data to/from other computers, could do the maths and calculate scores
</I>&gt;<i>  and decide when something is ripe for inclusion in &quot;release&quot; and
</I>&gt;<i>  automatically send it there, could verify all the crypto sig
</I>&gt;<i>  correctness and the integrity of all the data, could handle voting and
</I>&gt;<i>  could show a legislation tree as follows:
</I>&gt;<i>   * at each moment it shows one revision. The text is color coded for
</I>&gt;<i>  different authors and hovering the mouse on a passage shows who wrote
</I>&gt;<i>  it and when. Comments can be folded and unfolded.
</I>&gt;<i>   * a passage can be selected and its history summarized in a timeline
</I>&gt;<i>  that can be scrolled to quickly see how it had grown (animated)
</I>&gt;<i>   * a tree is shown, similar to the timeline, that can be moved through
</I>&gt;<i>  to quickly and animatedly browse different revisions and branches of
</I>&gt;<i>  the legislation
</I>&gt;<i>   * maybe there should be markers of fading visibility to indicate
</I>&gt;<i>  recently deleted passages
</I>&gt;<i>   * one can start editing at any point and the interface will
</I>&gt;<i>  automatically crypto-sign the edit and submit it (of course, an easy
</I>&gt;<i>  option to first branch the legislation should exist)
</I>&gt;<i>
</I>&gt;<i>  other features would be ability to browse user profiles and userpages
</I>&gt;<i>  and write there, but that is about the same things.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  This is it. There is no step four. I am astounded by how simple this
</I>&gt;<i>  all is once written down :) This makes me very happy, I thought it
</I>&gt;<i>  would be a much harder thing to implement. The math should be given
</I>&gt;<i>  thought that I didn't, but except for that my design probably works.
</I>&gt;<i>
</I>&gt;<i>   -- Aur
</I>&gt;<i>
</I>&gt;<i>  _______________________________________________
</I>&gt;<i>  Start mailing list
</I>&gt;<i>  <A HREF="http://metagovernment.org/mailman/listinfo/start_metagovernment.org">Start at metagovernment.org</A>
</I>&gt;<i>  <A HREF="http://metagovernment.org/mailman/listinfo/start_metagovernment.org">http://metagovernment.org/mailman/listinfo/start_metagovernment.org</A>
</I>&gt;<i>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="008954.html">[Start] A half baked vision
</A></li>
	<LI>Next message (by thread): <A HREF="008956.html">[Start] A half baked vision
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html">[ date ]</a>
              <a href="thread.html">[ thread ]</a>
              <a href="subject.html">[ subject ]</a>
              <a href="author.html">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://metagovernment.org/mailman/listinfo/start_metagovernment.org">More information about the Start
mailing list</a><br>
</body></html>
